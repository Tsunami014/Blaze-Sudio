from _typeshed import Incomplete
from mlflow import pyfunc as pyfunc
from mlflow.models import Model as Model
from mlflow.models.model import MLMODEL_FILE_NAME as MLMODEL_FILE_NAME
from mlflow.models.signature import ModelSignature as ModelSignature
from mlflow.models.utils import ModelInputExample as ModelInputExample
from mlflow.tracking._model_registry import DEFAULT_AWAIT_MAX_SLEEP_SECONDS as DEFAULT_AWAIT_MAX_SLEEP_SECONDS
from mlflow.utils.annotations import experimental as experimental
from mlflow.utils.docstring_utils import LOG_MODEL_PARAM_DOCS as LOG_MODEL_PARAM_DOCS, format_docstring as format_docstring
from mlflow.utils.file_utils import write_to as write_to
from mlflow.utils.uri import append_to_uri_path as append_to_uri_path

FLAVOR_NAME: str

def get_underlying_model_flavor(model): ...
def get_default_pip_requirements(): ...
def get_default_conda_env(): ...
def log_explanation(predict_function, features, artifact_path: Incomplete | None = None): ...
def log_explainer(explainer, artifact_path, serialize_model_using_mlflow: bool = True, conda_env: Incomplete | None = None, code_paths: Incomplete | None = None, registered_model_name: Incomplete | None = None, signature: ModelSignature = None, input_example: ModelInputExample = None, await_registration_for=..., pip_requirements: Incomplete | None = None, extra_pip_requirements: Incomplete | None = None): ...
def save_explainer(explainer, path, serialize_model_using_mlflow: bool = True, conda_env: Incomplete | None = None, code_paths: Incomplete | None = None, mlflow_model: Incomplete | None = None, signature: ModelSignature = None, input_example: ModelInputExample = None, pip_requirements: Incomplete | None = None, extra_pip_requirements: Incomplete | None = None): ...
save_model = save_explainer

def load_explainer(model_uri): ...

class _SHAPWrapper:
    explainer: Incomplete
    def __init__(self, path) -> None: ...
    def predict(self, dataframe): ...
