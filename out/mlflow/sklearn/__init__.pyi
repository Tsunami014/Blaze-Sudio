import pickle
from _typeshed import Incomplete
from mlflow import pyfunc as pyfunc
from mlflow.exceptions import MlflowException as MlflowException
from mlflow.models import Model as Model
from mlflow.models.model import MLMODEL_FILE_NAME as MLMODEL_FILE_NAME
from mlflow.models.signature import ModelSignature as ModelSignature
from mlflow.models.utils import ModelInputExample as ModelInputExample
from mlflow.protos.databricks_pb2 import INTERNAL_ERROR as INTERNAL_ERROR, INVALID_PARAMETER_VALUE as INVALID_PARAMETER_VALUE
from mlflow.tracking._model_registry import DEFAULT_AWAIT_MAX_SLEEP_SECONDS as DEFAULT_AWAIT_MAX_SLEEP_SECONDS
from mlflow.tracking.client import MlflowClient as MlflowClient
from mlflow.utils import gorilla as gorilla
from mlflow.utils.autologging_utils import INPUT_EXAMPLE_SAMPLE_ROWS as INPUT_EXAMPLE_SAMPLE_ROWS, MlflowAutologgingQueueingClient as MlflowAutologgingQueueingClient, autologging_integration as autologging_integration, disable_autologging as disable_autologging, get_autologging_config as get_autologging_config, get_instance_method_first_arg_value as get_instance_method_first_arg_value, resolve_input_example_and_signature as resolve_input_example_and_signature, safe_patch as safe_patch, update_wrapper_extended as update_wrapper_extended
from mlflow.utils.docstring_utils import LOG_MODEL_PARAM_DOCS as LOG_MODEL_PARAM_DOCS, format_docstring as format_docstring
from mlflow.utils.file_utils import write_to as write_to
from mlflow.utils.mlflow_tags import MLFLOW_AUTOLOGGING as MLFLOW_AUTOLOGGING

FLAVOR_NAME: str
SERIALIZATION_FORMAT_PICKLE: str
SERIALIZATION_FORMAT_CLOUDPICKLE: str
SUPPORTED_SERIALIZATION_FORMATS: Incomplete

def get_default_pip_requirements(include_cloudpickle: bool = False): ...
def get_default_conda_env(include_cloudpickle: bool = False): ...
def save_model(sk_model, path, conda_env: Incomplete | None = None, code_paths: Incomplete | None = None, mlflow_model: Incomplete | None = None, serialization_format=..., signature: ModelSignature = None, input_example: ModelInputExample = None, pip_requirements: Incomplete | None = None, extra_pip_requirements: Incomplete | None = None, pyfunc_predict_fn: str = 'predict'): ...
def log_model(sk_model, artifact_path, conda_env: Incomplete | None = None, code_paths: Incomplete | None = None, serialization_format=..., registered_model_name: Incomplete | None = None, signature: ModelSignature = None, input_example: ModelInputExample = None, await_registration_for=..., pip_requirements: Incomplete | None = None, extra_pip_requirements: Incomplete | None = None, pyfunc_predict_fn: str = 'predict'): ...

class _SklearnCustomModelPicklingError(pickle.PicklingError):
    original_exception: Incomplete
    def __init__(self, sk_model, original_exception) -> None: ...

def load_model(model_uri, dst_path: Incomplete | None = None): ...

class _AutologgingMetricsManager:
    def __init__(self) -> None: ...
    def should_log_post_training_metrics(self): ...
    def disable_log_post_training_metrics(self): ...
    @staticmethod
    def get_run_id_for_model(model): ...
    @staticmethod
    def is_metric_value_loggable(metric_value): ...
    def register_model(self, model, run_id) -> None: ...
    @staticmethod
    def gen_name_with_index(name, index): ...
    def register_prediction_input_dataset(self, model, eval_dataset): ...
    def register_prediction_result(self, run_id, eval_dataset_name, predict_result) -> None: ...
    @staticmethod
    def gen_metric_call_command(self_obj, metric_fn, *call_pos_args, **call_kwargs): ...
    def register_metric_api_call(self, run_id, metric_name, dataset_name, call_command): ...
    def get_run_id_and_dataset_name_for_metric_api_call(self, call_pos_args, call_kwargs): ...
    def log_post_training_metric(self, run_id, key, value): ...

def autolog(log_input_examples: bool = False, log_model_signatures: bool = True, log_models: bool = True, disable: bool = False, exclusive: bool = False, disable_for_unsupported_versions: bool = False, silent: bool = False, max_tuning_runs: int = 5, log_post_training_metrics: bool = True, serialization_format=..., registered_model_name: Incomplete | None = None, pos_label: Incomplete | None = None) -> None: ...
def eval_and_log_metrics(model, X, y_true, *, prefix, sample_weight: Incomplete | None = None, pos_label: Incomplete | None = None): ...
