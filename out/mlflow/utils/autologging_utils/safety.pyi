import abc
import typing
from _typeshed import Incomplete
from collections.abc import Generator

__all__ = ['safe_patch', 'is_testing', 'exception_safe_function_for_class', 'picklable_exception_safe_function', 'ExceptionSafeClass', 'ExceptionSafeAbstractClass', 'PatchFunction', 'with_managed_run', 'update_wrapper_extended']

def exception_safe_function_for_class(function): ...
def picklable_exception_safe_function(function): ...

ExceptionSafeClass: Incomplete
ExceptionSafeAbstractClass: Incomplete

class PatchFunction(metaclass=abc.ABCMeta):
    @classmethod
    def call(cls, original, *args, **kwargs): ...
    def __call__(self, original, *args, **kwargs): ...

def with_managed_run(autologging_integration, patch_function, tags: Incomplete | None = None): ...
def is_testing(): ...
def safe_patch(autologging_integration, destination, function_name, patch_function, manage_run: bool = False): ...

class AutologgingSession:
    integration: Incomplete
    id: Incomplete
    state: str
    def __init__(self, integration, id_) -> None: ...

class _AutologgingSessionManager:
    @classmethod
    def start_session(cls, integration) -> Generator[Incomplete, None, None]: ...
    @classmethod
    def active_session(cls): ...

def update_wrapper_extended(wrapper, wrapped): ...

class ValidationExemptArgument(typing.NamedTuple):
    autologging_integration: str
    function_name: str
    type_function: typing.Callable
    positional_argument_index: int = ...
    keyword_argument_name: str = ...
    def matches(self, autologging_integration, function_name, value, argument_index: Incomplete | None = None, argument_name: Incomplete | None = None): ...
