from _typeshed import Incomplete
from typing import Any, Iterable

Number = int | float
verboseOutput = Iterable[Any] | None
pointLike = Iterable[Number]
AVERYSMALLNUMBER: Number
BASEPRECISION: Number
BASEBOUNCINESS: Number

def rotate(origin: pointLike, point: pointLike, angle: Number) -> pointLike:
    """
    Rotate a point clockwise by a given angle around a given origin.
    The angle should be given in degrees.
    """
def rotateBy0(point: pointLike, angle: Number) -> pointLike:
    """
    Rotate a point clockwise by a given angle around the origin.
    The angle should be given in degrees.
    """
def direction(fromPoint: pointLike, toPoint: pointLike) -> Number:
    """
    Finds the direction of `toPoint` from the origin of `fromPoint`
    """
def pointOnUnitCircle(angle: Number, strength: Number) -> pointLike: ...

class Shape:
    x: Number
    y: Number
    bounciness: Incomplete
    def __init__(self, bounciness: float = ...) -> None: ...
    def collides(self, othershape: Shape | Shapes | Iterable['Shape']) -> bool: ...
    def whereCollides(self, othershape: Shape | Shapes | Iterable['Shape']) -> Iterable[pointLike]: ...
    def check_rects(self, othershape: Shape): ...
    def closestPointTo(self, othershape: Shape, returnAll: bool = False) -> pointLike | Iterable[pointLike]: ...
    def isCorner(self, point: pointLike, precision: Number = ...) -> bool: ...
    def tangent(self, point: pointLike, accel: pointLike) -> Number: ...
    def rect(self) -> Iterable[Number]: ...
    def handleCollisionsPos(self, oldP: Shape, newP: Shape, objs: Shapes | Iterable['Shape'], accel: pointLike = [0, 0]) -> tuple['Shape', pointLike]: ...
    def handleCollisionsAccel(self, accel: pointLike, objs: Shapes | Iterable['Shape']) -> tuple['Shape', pointLike]: ...
    def copy(self) -> Shape: ...
    def __getitem__(self) -> None: ...
    def __setitem__(self) -> None: ...

class Shapes:
    shapes: Incomplete
    def __init__(self, *shapes: Shape) -> None: ...
    def add_shape(self, shape: Shape) -> None: ...
    def add_shapes(self, *shapes: Shape | Shapes) -> None: ...
    def remove_shape(self, shape: Shape) -> None: ...
    def remove_shapes(self, *shapes: Shape | Shapes) -> None: ...
    def collides(self, shapes: Shape | Shapes) -> bool: ...
    def whereCollides(self, shapes: Shape | Shapes) -> Iterable[pointLike]: ...
    def closestPointTo(self, othershape: Shape, returnAll: bool = False) -> Iterable[pointLike]: ...
    def isCorner(self, point: pointLike, precision: Number = ...) -> dict[None]: ...
    def tangent(self, point: pointLike, accel: pointLike) -> pointLike: ...
    def rect(self) -> Iterable[Number]: ...
    def copy(self) -> Shapes: ...
    def copy_leave_shapes(self) -> Shapes: ...
    def __iter__(self): ...
    def __getitem__(self, index: Number) -> Shape | Shapes: ...
    def __setitem__(self, index: Number, new: Shape | Shapes) -> None: ...

class Point(Shape):
    def __init__(self, x: Number, y: Number, bounciness: float = ...) -> None: ...
    def rect(self) -> Iterable[Number]: ...
    def closestPointTo(self, othershape: Shape, returnAll: bool = False) -> pointLike | Iterable[pointLike]: ...
    def getTuple(self) -> tuple[Number]: ...
    def handleCollisionsPos(self, oldPoint: Point | pointLike, newPoint: Point | pointLike, objs: Shapes | Iterable[Shape], accel: pointLike = [0, 0], replaceSelf: bool = True, precision: Number = ...) -> tuple['Point', pointLike]: ...
    def handleCollisionsAccel(self, accel: pointLike, objs: Shapes | Iterable[Shape], replaceSelf: bool = True, precision: Number = ...) -> tuple['Point', pointLike]: ...
    def copy(self) -> Point: ...
    def __getitem__(self, item: Number) -> Number: ...
    x: Incomplete
    y: Incomplete
    def __setitem__(self, item: Number, new: Number) -> None: ...

class Line(Shape):
    def __init__(self, p1: pointLike, p2: pointLike, bounciness: float = ...) -> None: ...
    @property
    def x(self): ...
    p1: Incomplete
    p2: Incomplete
    @x.setter
    def x(self, value) -> None: ...
    @property
    def y(self): ...
    @y.setter
    def y(self, value) -> None: ...
    def rect(self) -> Iterable[Number]: ...
    def closestPointTo(self, othershape: Shape, returnAll: bool = False) -> pointLike | Iterable[pointLike]: ...
    def isCorner(self, point: pointLike, precision: Number = ...) -> bool: ...
    def tangent(self, point: pointLike, accel: pointLike) -> Number: ...
    def handleCollisionsPos(self, oldLine: Line, newLine: Line, objs: Shapes | Iterable[Shape], accel: pointLike = [0, 0], replaceSelf: bool = True, precision: Number = ..., verbose: bool = False) -> tuple['Line', pointLike, verboseOutput]: ...
    def handleCollisionsAccel(self, accel: pointLike, objs: Shapes | Iterable[Shape], replaceSelf: bool = True, precision: Number = ..., verbose: bool = False) -> tuple['Line', pointLike, verboseOutput]: ...
    def copy(self) -> Line: ...
    def __getitem__(self, item: Number) -> pointLike: ...
    def __setitem__(self, item: Number, new: pointLike) -> None: ...

class Circle(Shape):
    def __init__(self, x: Number, y: Number, r: Number, bounciness: float = ...) -> None: ...
    def rect(self) -> Iterable[Number]: ...
    def closestPointTo(self, othershape: Shape, returnAll: bool = False) -> pointLike | Iterable[pointLike]: ...
    def isCorner(self, point: pointLike, precision: Number = ...) -> bool: ...
    def tangent(self, point: pointLike, accel: pointLike) -> Number: ...
    def copy(self) -> Circle: ...
    def __getitem__(self, item: Number) -> Number: ...
    x: Incomplete
    y: Incomplete
    r: Incomplete
    def __setitem__(self, item: Number, new: Number) -> None: ...

class ClosedShape(Shape):
    def tangent(self, point: pointLike, accel: pointLike) -> Number: ...
    def closestPointTo(self, othershape: Shape, returnAll: bool = False) -> pointLike | Iterable[pointLike]: ...
    def handleCollisionsPos(self, oldShp: ClosedShape, newShp: ClosedShape, objs: Shapes | Iterable[Shape], accel: pointLike = [0, 0], replaceSelf: bool = True, precision: Number = ..., verbose: bool = False) -> tuple['ClosedShape', pointLike, verboseOutput]: ...
    def handleCollisionsAccel(self, accel: pointLike, objs: Shapes | Iterable[Shape], replaceSelf: bool = True, precision: Number = ..., verbose: bool = False) -> tuple['ClosedShape', pointLike, verboseOutput]: ...
    def isCorner(self, point: pointLike, precision: Number = ...) -> bool: ...
    def toLines(self): ...
    def toPoints(self) -> Iterable[pointLike]: ...
    def __getitem__(self, item: Number) -> pointLike: ...

class Rect(ClosedShape):
    def __init__(self, x: Number, y: Number, w: Number, h: Number, bounciness: float = ...) -> None: ...
    def rect(self) -> Iterable[Number]: ...
    def toLines(self) -> Iterable[Line]: ...
    def toPoints(self) -> Iterable[pointLike]: ...
    def copy(self) -> Rect: ...
    def __setitem__(self, item: Number, new: pointLike) -> None: ...

class RotatedRect(ClosedShape):
    cachedPoints: Incomplete
    cacheRequirements: Incomplete
    def __init__(self, x: Number, y: Number, w: Number, h: Number, rotation: Number, bounciness: float = ...) -> None: ...
    cache: Incomplete
    def getCache(self) -> Iterable[pointLike]: ...
    def rect(self) -> Iterable[Number]: ...
    def toPoints(self) -> Iterable[pointLike]: ...
    def toLines(self) -> Iterable[Line]: ...
    def copy(self) -> RotatedRect: ...
    def __setitem__(self, item: Number, new: pointLike) -> None: ...

class Polygon(ClosedShape):
    points: Incomplete
    def __init__(self, *points: pointLike, errorOnLT3: bool = True, bounciness: float = ...) -> None: ...
    @property
    def x(self): ...
    @x.setter
    def x(self, new) -> None: ...
    @property
    def y(self): ...
    @y.setter
    def y(self, new) -> None: ...
    def rect(self) -> Iterable[Number]: ...
    def toLines(self) -> Iterable[Line]: ...
    def toPoints(self) -> Iterable[pointLike]: ...
    def copy(self) -> Polygon: ...
    def __setitem__(self, item: Number, new: pointLike) -> None: ...

class ShapeCombiner:
    @classmethod
    def bounding_box(cls, *shapes: Rect) -> Shapes: ...
    @classmethod
    def to_rects(cls, *shapes: Rect) -> Shapes: ...
    @classmethod
    def to_polygons(cls, *shapes: Shape) -> Shapes: ...
