import abc
import numpy as np
from _typeshed import Incomplete
from abc import ABC, abstractmethod
from enum import IntEnum

__all__ = ['OpFlags', 'Op', 'TransOp', 'MatOp', 'OpList']

class OpFlags(IntEnum):
    """
    Flags that make Operations act differently.
    Only for manual use if you know what you're doing.
    """
    NoFlags = 0
    List = 1
    Matrix = 2
    Transformable = 4
    Reset = 8

class Op(ABC, metaclass=abc.ABCMeta):
    """Please, wherever possible, use TransOps instead. It's faster."""
    @abstractmethod
    def __init__(self): ...
    @abstractmethod
    def apply(self, arr: np.ndarray, defSmth: bool) -> np.ndarray: ...
    flags: Incomplete
    def freeze(self) -> None: ...
    def frozen(self) -> Op: ...
    def __add__(self, oth) -> OpList: ...
    def flatten(self): ...

class TransOp(Op, metaclass=abc.ABCMeta):
    flags: Incomplete
    def __init__(self) -> None: ...
    def apply(self, arr, _): ...
    @abstractmethod
    def applyTrans(self, mat: np.ndarray, arr: np.ndarray) -> np.ndarray: ...

class MatOp(Op):
    mat: Incomplete
    flags: Incomplete
    def __init__(self, mat, smooth=None) -> None: ...
    def stack(self, nxt: MatOp): ...
    def apply(self, arr: np.ndarray, defSmth: bool): ...

class OpList(Op):
    ops: Incomplete
    flags: Incomplete
    def __init__(self, *ops) -> None: ...
    def fix(self) -> None: ...
    def freeze(self) -> None: ...
    def frozen(self) -> Op: ...
    def apply(self, arr: np.ndarray, defSmth): ...
    def __add__(self, oth) -> OpList: ...
    def flatten(self): ...
